#!/usr/bin/python3

# Author: Emmanuel Odeke <odeke@ualberta.ca>
# Permutation generator

# Method of generating permutations by looking
# at proper subsets generated by taking one element out of the original
# set and then expanding along recursively until the proper 
# subset contains two elements or less

from math import factorial

def expandTree(tree):
  orderingList = list()
  for key, value in tree.items():
    if isinstance(value, dict):
      for ordering in expandTree(value):
        orderingList.append("%s%s"%(key, "".join(ordering)))
    if isinstance(value, list):
      for elem in value:
        orderingList.append("%s%s"%(key, "".join(elem)))
  return orderingList

def makeTree(alphabet, axiomMemoizer):
  baseAxioms = dict()
  for member in alphabet: 
    properSet = tuple([elem for elem in alphabet if elem != member])
    if len(properSet) == 2:
      baseAxioms[member] = computePerm(properSet, axiomMemoizer)
    else:
      baseAxioms[member] = makeTree(properSet, axiomMemoizer)
  return baseAxioms

def computePerm(base, axiomMemoizer):
  baseLen = len(base)
  if baseLen <= 1:
    return None
  elif baseLen == 2:
    if base[0] != base[1]:
      if not axiomMemoizer.get(base, None):
         a, b = base
         axiomMemoizer[base] = [(a, b), (b, a)]
      return axiomMemoizer[base]
    else:
      print("Must be a set ", base)
      
def main():
  alphabet = [str(i) for i in range(8)] # ['a', 'X', 'Z', '2', '3']
  n = len(alphabet)
  k = makeTree(set(alphabet), dict())

  permutation = expandTree(k)
 
  # Permutation should return a list of elements of length equal to n!
  assert(len(permutation) == factorial(n))

  print(permutation)

if __name__ == '__main__':
  main()
